---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/env/client.ts
  - src/env/db.ts
  - src/db/index.ts
  - src/db/schema.ts
  - drizzle.config.ts
  - .env.local
autonomous: false
user_setup:
  - service: neon
    why: "Serverless Postgres database for intent form submissions"
    env_vars:
      - name: DATABASE_URL
        source: "Neon Console -> Project -> Connection Details -> Connection string (with ?sslmode=require)"
    dashboard_config:
      - task: "Create a Neon project (free tier)"
        location: "https://console.neon.tech -> New Project"

must_haves:
  truths:
    - "Missing or invalid DATABASE_URL causes a clear error message, not a silent failure"
    - "Drizzle schema defines intent_submissions table with id, intent, name, email, locale, created_at"
    - "Database migration creates the intent_submissions table in Neon Postgres"
    - "Drizzle can query the database (db.select().from(intentSubmissions) returns empty array)"
  artifacts:
    - path: "src/env/client.ts"
      provides: "Type-safe client environment variables (PostHog keys)"
      contains: "createEnv"
    - path: "src/env/db.ts"
      provides: "Type-safe server environment variables (DATABASE_URL)"
      contains: "DATABASE_URL"
    - path: "src/db/schema.ts"
      provides: "Drizzle schema with intentSubmissions table and enums"
      contains: "intentSubmissions"
    - path: "src/db/index.ts"
      provides: "Module-level Drizzle singleton for serverless connection"
      contains: "export const db"
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration for migrations"
      contains: "defineConfig"
  key_links:
    - from: "src/db/index.ts"
      to: "src/env/db.ts"
      via: "Database URL import"
      pattern: "import.*env/db"
    - from: "src/db/index.ts"
      to: "src/db/schema.ts"
      via: "Schema import for type inference"
      pattern: "import.*schema"
    - from: "drizzle.config.ts"
      to: "src/db/schema.ts"
      via: "Schema path for migration generation"
      pattern: "schema.*db/schema"
    - from: "next.config.ts"
      to: "src/env/client.ts"
      via: "Build-time env validation import (created in Plan 01-01)"
      pattern: "import.*env/client"
---

<objective>
Set up type-safe environment variables with @t3-oss/env-nextjs, configure Drizzle ORM with Neon serverless Postgres, define the intent_submissions database schema, and run the initial migration.

Purpose: This plan establishes the data layer. After completion, the database connection is verified, the schema is pushed, and environment variables are validated at build time. This is the foundation for the intent form in Phase 3.
Output: Working database connection with schema, type-safe env vars, and migration tooling.
</objective>

<execution_context>
@/home/hybridz/.claude/get-shit-done/workflows/execute-plan.md
@/home/hybridz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/hybridz/Projects/404tf/.planning/PROJECT.md
@/home/hybridz/Projects/404tf/.planning/ROADMAP.md
@/home/hybridz/Projects/404tf/.planning/phases/01-foundation/01-RESEARCH.md

Reference (read-only, for exact config patterns):
@/home/hybridz/Projects/next-fullstack-template/src/env/client.ts
@/home/hybridz/Projects/next-fullstack-template/src/env/db.ts
@/home/hybridz/Projects/next-fullstack-template/src/db/index.ts
@/home/hybridz/Projects/next-fullstack-template/drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up @t3-oss/env-nextjs with type-safe env vars</name>
  <files>
    src/env/client.ts
    src/env/db.ts
    .env.local
  </files>
  <action>
1. Create `src/env/client.ts` for client-side environment variables:
   ```typescript
   import { createEnv } from "@t3-oss/env-nextjs";
   import { z } from "zod";

   export const clientEnv = createEnv({
     client: {
       NEXT_PUBLIC_POSTHOG_KEY: z.string().min(1).optional(),
       NEXT_PUBLIC_POSTHOG_HOST: z.string().url().optional(),
     },
     runtimeEnv: {
       NEXT_PUBLIC_POSTHOG_KEY: process.env.NEXT_PUBLIC_POSTHOG_KEY,
       NEXT_PUBLIC_POSTHOG_HOST: process.env.NEXT_PUBLIC_POSTHOG_HOST,
     },
     server: {},
     emptyStringAsUndefined: true,
   });
   ```
   NOTE: PostHog vars are `.optional()` because they are not needed until Phase 5. Making them required now would block `bun dev` and `bun build` in Phases 1-4.

2. Create `src/env/db.ts` for server-side database environment variables:
   - Import `createEnv` from `@t3-oss/env-nextjs` and `z` from `zod`
   - Define a custom `neonUrlSchema` Zod validator that:
     a. Checks it is a valid URL
     b. Checks it starts with `postgresql://`
     c. Refines to verify username, password, and hostname are present
   - Create env with:
     - server.DATABASE_URL: neonUrlSchema (required)
     - server.NODE_ENV: z.enum(["development", "test", "production"]).default("development")
     - runtimeEnv: process.env
     - isServer: true (prevents client detection errors in test environments)
     - emptyStringAsUndefined: true
     - client: {} (no client vars in this file)
   - Export `databaseUrl` as `dbEnv.DATABASE_URL`
   - Follow research Pattern 6 exactly, but make DATABASE_URL required (not optional) since the data layer plan requires it

3. Create `.env.local` with placeholder values:
   ```
   # Neon Postgres connection string
   # Get from: Neon Console -> Project -> Connection Details
   DATABASE_URL=

   # PostHog (Phase 5 -- leave empty for now)
   NEXT_PUBLIC_POSTHOG_KEY=
   NEXT_PUBLIC_POSTHOG_HOST=
   ```
   NOTE: The user must fill in DATABASE_URL with their actual Neon connection string before running `bun dev` or `bun run db:push`. The checkpoint task below handles this.

IMPORTANT: The `next.config.ts` created in Plan 01-01 already has `await import("./src/env/client.js")`. This file (`src/env/client.ts`) is what that import resolves to. Once this file exists, the build-time env validation is active.
  </action>
  <verify>
    Verify `src/env/client.ts` exists and contains `createEnv`.
    Verify `src/env/db.ts` exists and contains `DATABASE_URL` validation.
    Verify `.env.local` exists.
    Run `bunx tsc --noEmit` to check for TypeScript errors in env files.
  </verify>
  <done>
    Type-safe environment variables configured. Client env validates PostHog keys (optional for now). Server env validates DATABASE_URL with custom Neon URL schema. .env.local template created for user to fill in. Build-time validation wired through next.config.ts import.
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: User provides Neon DATABASE_URL</name>
  <what-needs-doing>
    The database connection requires a Neon Postgres connection string that Claude cannot obtain.
  </what-needs-doing>
  <instructions>
    1. Go to https://console.neon.tech
    2. Create a new project (or use existing) -- free tier is fine
    3. Copy the connection string from: Project -> Connection Details -> Connection string
    4. Paste the connection string into `.env.local` as the DATABASE_URL value
    5. The URL should look like: `postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require`
    6. Type "done" when the DATABASE_URL is set
  </instructions>
  <resume-signal>Type "done" when DATABASE_URL is set in .env.local</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Set up Drizzle ORM schema and run migration</name>
  <files>
    src/db/schema.ts
    src/db/index.ts
    drizzle.config.ts
  </files>
  <action>
1. Create `src/db/schema.ts` with the intent_submissions table (research Pattern 5 / Example 2):
   ```typescript
   import { pgTable, text, timestamp, uuid, pgEnum } from "drizzle-orm/pg-core";

   export const intentEnum = pgEnum("intent", ["build", "collaborate", "connect"]);
   export const localeEnum = pgEnum("locale", ["es", "en"]);

   export const intentSubmissions = pgTable("intent_submissions", {
     id: uuid("id").defaultRandom().primaryKey(),
     intent: intentEnum("intent").notNull(),
     name: text("name").notNull(),
     email: text("email").notNull(),
     locale: localeEnum("locale").notNull(),
     createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
   });

   export type IntentSubmission = typeof intentSubmissions.$inferSelect;
   export type NewIntentSubmission = typeof intentSubmissions.$inferInsert;
   ```

2. Create `src/db/index.ts` with module-level singleton (research Pattern 5):
   ```typescript
   import { drizzle } from "drizzle-orm/neon-serverless";
   import { databaseUrl } from "@/env/db";
   import * as schema from "./schema";

   export const db = drizzle(databaseUrl, { schema });
   ```
   CRITICAL: Module-level export (singleton). Do NOT wrap in a function -- that creates new connections per call and exhausts Neon connection limits.

3. Create `drizzle.config.ts` in project root:
   ```typescript
   import { defineConfig } from "drizzle-kit";

   export default defineConfig({
     schema: "./src/db/schema.ts",
     out: "./src/db/migrations",
     dialect: "postgresql",
     dbCredentials: {
       url: process.env.DATABASE_URL!,
     },
     strict: true,
     verbose: true,
   });
   ```
   NOTE: drizzle.config.ts uses `process.env.DATABASE_URL!` directly (not the @t3-oss/env wrapper) because drizzle-kit runs as a standalone CLI tool outside the Next.js build pipeline.

4. Run schema push to create the table in Neon:
   ```bash
   bun run db:push
   ```
   This should create:
   - `intent` enum type (build, collaborate, connect)
   - `locale` enum type (es, en)
   - `intent_submissions` table with all 6 columns

5. Verify the database connection works by running a quick test:
   ```bash
   bun -e "
   import { db } from './src/db/index.ts';
   import { intentSubmissions } from './src/db/schema.ts';
   const result = await db.select().from(intentSubmissions);
   console.log('Connection OK. Rows:', result.length);
   process.exit(0);
   "
   ```
   Expected output: "Connection OK. Rows: 0"
  </action>
  <verify>
    Run `bun run db:push` exits with code 0 and reports table creation.
    Run the inline bun script to verify database query returns empty array.
    Run `bunx tsc --noEmit` -- all TypeScript files should compile without errors.
    Run `bun run check` -- Biome should pass with zero errors on all new files.
  </verify>
  <done>
    Drizzle ORM configured with Neon serverless Postgres. intent_submissions table exists in the database with id (UUID), intent (enum), name, email, locale (enum), and created_at columns. Module-level db singleton exports correctly. drizzle.config.ts enables migration generation and Drizzle Studio. Database connection verified with a test query returning empty results.
  </done>
</task>

</tasks>

<verification>
1. `src/env/client.ts` validates PostHog vars (optional) at build time via next.config.ts import
2. `src/env/db.ts` validates DATABASE_URL with custom Neon URL schema
3. `bun run db:push` succeeds -- intent_submissions table exists in Neon
4. `bun -e "..."` test query returns "Connection OK. Rows: 0"
5. `bunx tsc --noEmit` passes with zero errors
6. `bun run check` (Biome) passes with zero errors
7. `bun dev` starts the dev server and renders /es and /en pages (confirming env validation passes)
</verification>

<success_criteria>
- @t3-oss/env-nextjs validates environment variables at build time
- Missing DATABASE_URL produces a clear Zod validation error, not a runtime crash
- Drizzle ORM connects to Neon Postgres via neon-serverless HTTP driver
- intent_submissions table exists with correct columns and enum types
- Module-level db singleton pattern prevents connection exhaustion
- drizzle.config.ts enables `bun run db:generate`, `bun run db:push`, `bun run db:studio`
- All files pass Biome lint and TypeScript type-checking
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
